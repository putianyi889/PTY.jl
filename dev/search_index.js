var documenterSearchIndex = {"docs":
[{"location":"#PTY.jl","page":"PTY.jl","title":"PTY.jl","text":"","category":"section"},{"location":"","page":"PTY.jl","title":"PTY.jl","text":"Documentation for PTY.jl","category":"page"},{"location":"#Type-piracies-by-PTY.Helper","page":"PTY.jl","title":"Type piracies by PTY.Helper","text":"","category":"section"},{"location":"","page":"PTY.jl","title":"PTY.jl","text":"// falls back to / for float inputs\n: for range construction now supports complex arithmetic progressions\nAbstractArray{T, N}(A::BroadcastArray{S, N}) for eltype conversion","category":"page"},{"location":"#PTY.TR-for-Terraria","page":"PTY.jl","title":"PTY.TR for Terraria","text":"","category":"section"},{"location":"","page":"PTY.jl","title":"PTY.jl","text":"Modules = [PTY.TR]","category":"page"},{"location":"#PTY.TR.CombGate","page":"PTY.jl","title":"PTY.TR.CombGate","text":"(AndGate|XorGate){T<:Integer, V<:AbstractVector{<:Integer}}(gatestate::Bool, args::T, lampstates::V) <:AbstractGate\nCombGate{T, V} = Union{AndGate{T, V}, XorGate{T, V}}\n\nCombinatory gates in Terraria. gatestate tells the default (when all inputs are zero) state of the gate. args tells the number of inputs. lampstates lists how the inputs are wired to each logic lamp. \n\nExample\n\nConsider AndGate(false, 4, [0x12, 0x09, 0x04]). It's an AND gate whose default state is OFF. Since there are 4 args (named a-d), we consider the last 5 bits of each entry of lampstates. The leading bit tells the default state of the lamps. The other 4 bits (from lower to higher) tell which args are wired to the lamp. i.e.,\n\n0x12 = 0b10010 means the default state of the first lamp is ON and only b is connected to the lamp.\n0x09 = 0b01001 means the default state of the second lamp is OFF and a and d are connected to the lamp.\n0x04 = 0b00100 means the default state of the third lamp is OFF and only c is connected to the lamp.\n\njulia> TR.AndGate(false, 4, [0x12, 0x09, 0x04])\n&(~b, ad, c)\n\nThe output is visualized via gate2string.\n\n\n\n\n\n","category":"type"},{"location":"#PTY.TR.AndGate","page":"PTY.jl","title":"PTY.TR.AndGate","text":"(AndGate|XorGate){T<:Integer, V<:AbstractVector{<:Integer}}(gatestate::Bool, args::T, lampstates::V) <:AbstractGate\nCombGate{T, V} = Union{AndGate{T, V}, XorGate{T, V}}\n\nCombinatory gates in Terraria. gatestate tells the default (when all inputs are zero) state of the gate. args tells the number of inputs. lampstates lists how the inputs are wired to each logic lamp. \n\nExample\n\nConsider AndGate(false, 4, [0x12, 0x09, 0x04]). It's an AND gate whose default state is OFF. Since there are 4 args (named a-d), we consider the last 5 bits of each entry of lampstates. The leading bit tells the default state of the lamps. The other 4 bits (from lower to higher) tell which args are wired to the lamp. i.e.,\n\n0x12 = 0b10010 means the default state of the first lamp is ON and only b is connected to the lamp.\n0x09 = 0b01001 means the default state of the second lamp is OFF and a and d are connected to the lamp.\n0x04 = 0b00100 means the default state of the third lamp is OFF and only c is connected to the lamp.\n\njulia> TR.AndGate(false, 4, [0x12, 0x09, 0x04])\n&(~b, ad, c)\n\nThe output is visualized via gate2string.\n\n\n\n\n\n","category":"type"},{"location":"#PTY.TR.XorGate","page":"PTY.jl","title":"PTY.TR.XorGate","text":"(AndGate|XorGate){T<:Integer, V<:AbstractVector{<:Integer}}(gatestate::Bool, args::T, lampstates::V) <:AbstractGate\nCombGate{T, V} = Union{AndGate{T, V}, XorGate{T, V}}\n\nCombinatory gates in Terraria. gatestate tells the default (when all inputs are zero) state of the gate. args tells the number of inputs. lampstates lists how the inputs are wired to each logic lamp. \n\nExample\n\nConsider AndGate(false, 4, [0x12, 0x09, 0x04]). It's an AND gate whose default state is OFF. Since there are 4 args (named a-d), we consider the last 5 bits of each entry of lampstates. The leading bit tells the default state of the lamps. The other 4 bits (from lower to higher) tell which args are wired to the lamp. i.e.,\n\n0x12 = 0b10010 means the default state of the first lamp is ON and only b is connected to the lamp.\n0x09 = 0b01001 means the default state of the second lamp is OFF and a and d are connected to the lamp.\n0x04 = 0b00100 means the default state of the third lamp is OFF and only c is connected to the lamp.\n\njulia> TR.AndGate(false, 4, [0x12, 0x09, 0x04])\n&(~b, ad, c)\n\nThe output is visualized via gate2string.\n\n\n\n\n\n","category":"type"},{"location":"#PTY.TR.CombLogic-Tuple{Integer, AbstractVector{<:Integer}, AbstractVector{Bool}}","page":"PTY.jl","title":"PTY.TR.CombLogic","text":"CombLogic(lamps, inputs, outputs::AbstractVector{Bool})\n\nReturn the lists of possible combinatory logics for given inputs and outputs.\n\nArguments\n\nlamps::Integer: the number of logic lamps on the gate, from 2 to 7.\ninputs::AbstractVector{<:Integer}: the list of input values specified by the lower bits of entries, with a 1 in front of the first bit.\noutputs::AbstractVector{Bool}: the expected return values of the logic. This should have the same length as inputs, although it's not strictly checked.\n\nExample\n\nImagine we want to check if a 4-bit input can be divided by 3. Further, the input is expected to have only one decimal digit, i.e. in 0:9. We don't care how the logic behaves for inputs 10:15. The truth table would be\n\nin out  in out\n0000 true  0101 false\n0001 false  0110 true\n0010 false  0111 false\n0011 true  1000 false\n0100 false  1001 true\n\nNow we try to find a configuration with least lamps.\n\njulia> inputs = 16:25; # `0:9` with the 5th last bit set to `1`\n\njulia> outputs = [true, false, false, true, false, false, true, false, false, true];\n\njulia> TR.CombLogic(2, inputs, outputs) # there is no 2-lamp logic\nPTY.TR.CombGate{Int64, StaticArraysCore.SVector{2, UInt8}}[]\n\njulia> TR.CombLogic(3, inputs, outputs) # there are 12 3-lamp logics, all of which use XOR gates\n12-element Vector{PTY.TR.CombGate{Int64, StaticArraysCore.SVector{3, UInt8}}}:\n ^(~b, ad, c)\n ^(~b, abd, bc)\n ^(~ac, ad, ab)\n ^(~ac, abd, a)\n ^(~ac, cd, bc)\n ^(~ac, bcd, c)\n ^(~bd, c, a)\n ^(~bd, bc, ab)\n ^(~bd, cd, ad)\n ^(~bd, bcd, abd)\n ^(~acd, bc, c)\n ^(~acd, abd, ad)\n\nSee also CombGate\n\n\n\n\n\n","category":"method"},{"location":"#PTY.TR.gate2string-Tuple{PTY.TR.CombGate}","page":"PTY.jl","title":"PTY.TR.gate2string","text":"gate2string(G::CombGate)\n\nConvert a CombGate into a readable string. See also CombGate, lampstate2string, logicsymb.\n\n\n\n\n\n","category":"method"},{"location":"#PTY.TR.lampstate2string-Tuple{Integer, Integer}","page":"PTY.jl","title":"PTY.TR.lampstate2string","text":"lampstate2string(lampstate::Integer, args::Integer)\n\nConvert binary coded lampstate into a readable string. args tells the number of distinct inputs.\n\nExamples\n\njulia> TR.lampstate2string(0b1111, 4)\n\"abcd\"\n\njulia> TR.lampstate2string(0b11101, 4)\n\"~acd\"\n\njulia> TR.lampstate2string(0b10000, 4)\n\"~\"\n\n\n\n\n\n","category":"method"},{"location":"#PTY.TR.logicsymb-Tuple{typeof(PTY.TR.AND)}","page":"PTY.jl","title":"PTY.TR.logicsymb","text":"logicsymb(::typeof(AND|XOR)|::CombGate)\n\nReturn '&' or '^' according to input.\n\n\n\n\n\n","category":"method"},{"location":"#PTY.TR.nthbit-Tuple{Integer, Integer}","page":"PTY.jl","title":"PTY.TR.nthbit","text":"nthbit(x::Integer, n::Integer)\n\nGet the n-th last bit of x.\n\nExample\n\njulia> [TR.nthbit(0b10110, n) for n in 1:5]\n5-element Vector{Bool}:\n 0\n 1\n 1\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"#PTY.SpecFun-for-special-functions","page":"PTY.jl","title":"PTY.SpecFun for special functions","text":"","category":"section"},{"location":"","page":"PTY.jl","title":"PTY.jl","text":"Modules = [PTY.SpecFun]","category":"page"},{"location":"#PTY.SpecFun.fracpochhammer-Tuple{Any, Any, Any}","page":"PTY.jl","title":"PTY.SpecFun.fracpochhammer","text":"fracpochhammer(a, b, n)\n\nCalculate the fraction of two Pochhammer symbols frac(a)_n(b)_n by multiplying the fractions. This approach reduces the risk of overflow/underflow when n is large.\n\nExamples\n\njulia> SpecFun.fracpochhammer(1, 2, 3) # (1 * 2 * 3) / (2 * 3 * 4)\n0.25\n\nfracpochhammer(a, b, stepa, stepb, n)\n\nSimilar to fracpochhammer(a, b, n), except that the steps of the Pochhammer symbols are not necessarily 1.\n\nExamples\n\njulia> SpecFun.fracpochhammer(1, 2, 0.5, 1, 3) # (1 * 1.5 * 2) / (2 * 3 * 4)\n0.125\n\n\n\n\n\n","category":"method"},{"location":"#PTY.SpecFun.mittleff-NTuple{4, Any}","page":"PTY.jl","title":"PTY.SpecFun.mittleff","text":"mittleff(α, β, γ, z)\nmittleff(α, β, z) = mittleff(α, β, 1, z)\nmittleff(α, z) = mittleff(α, 1, z)\n\nCompute the Mittag-Leffler function of one variable z. The codes are translated from https://uk.mathworks.com/matlabcentral/fileexchange/48154-the-mittag-leffler-function\n\n\n\n\n\n","category":"method"},{"location":"#PTY.ContFrac-for-continued-fractions","page":"PTY.jl","title":"PTY.ContFrac for continued fractions","text":"","category":"section"},{"location":"","page":"PTY.jl","title":"PTY.jl","text":"Modules = [PTY.ContFrac]","category":"page"},{"location":"#PTY.ContFrac.ContinuedFraction","page":"PTY.jl","title":"PTY.ContFrac.ContinuedFraction","text":"ContinuedFraction(b0, a, b)\n\nThe continued fraction b_0+fraca_1b_1+fraca_2b_2+fraca_3b_3+fraca_4b_4+cdots. Each entry represents a truncated fraction.\n\nExample\n\njulia> using InfiniteArrays, FillArrays\n\njulia> ContFrac.ContinuedFraction(1, Ones{Int}(∞), Ones{Int}(∞)) # the golden ratio\nℵ₀-element PTY.ContFrac.ContinuedFraction{Rational{Int64}, Ones{Rational{Int64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}, Ones{Rational{Int64}, 1, Tuple{InfiniteArrays.OneToInf{Int64}}}} with indices OneToInf():\n   2//1\n   3//2\n   5//3\n   8//5\n  13//8\n  21//13\n  34//21\n  55//34\n  89//55\n 144//89\n    ⋮\n\n\n\n\n\n","category":"type"},{"location":"#PTY.ContFrac.cfrac-Union{Tuple{T}, Tuple{typeof(exp), T}} where T","page":"PTY.jl","title":"PTY.ContFrac.cfrac","text":"cfrac(f, x)\n\nThe continued fraction converging to f(x). Currently supported functions: exp, log, sin, tan, csc, atanh\n\n\n\n\n\n","category":"method"},{"location":"#PTY.Infs-for-infinities","page":"PTY.jl","title":"PTY.Infs for infinities","text":"","category":"section"},{"location":"","page":"PTY.jl","title":"PTY.jl","text":"This is an experiment of rewriting Infinities.jl. This module is not expected to work at present.","category":"page"}]
}
